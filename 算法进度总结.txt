1、双指针法：就是在遍历数组或者链表中设置两个指针，根据指针运动方向的不同可以分为
    1.1 同向双指针(滑动窗口)
    1.2 对向（碰撞）双指针
    1.3 快慢指针：一般用于解决链表中的问题：
        比如：寻找链表的[中间点]寻找链表中倒数第K个元素、判断链表中是否存在环、排序链表（1、找中间点使用归并排序，2、插入排序 3、冒泡排序）
2、二分查找法：需要数组有序
3、栈：单调栈的特性，求解左侧或右侧最大值、最小，可以机选面积之类的
 比如：接雨水、k长度的最大元素 、最大面积

4、前后缀分解法：好下表的元素
https://zhuanlan.zhihu.com/p/671839485
前缀和:所谓前缀和，是指一个数组中的前i项的和。设有数组a[0...n]，那么s[i] = a[0] + ... + a[i]。
这样s数组就是a数组的前缀和数组。
前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和

4.1、差分数组：
        差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。

https://zhuanlan.zhihu.com/p/637328901
5、滑动窗口:是双指针的一种特例算法，窗口大小固定，使用右指针向右移动。保持窗口期大小固定
    https://blog.csdn.net/qq_74534898/article/details/131563779

6、双指针算法：

8、四大算法之一---贪心算法：是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解
 比如：最短路径算法、找零钱、小孩分饼干，分发糖果
9、四大算法之：分治算法：分治算法是将一个规模为N的问题分解为K个规模较小的子问题;
     就是把一个的大规模的问题分解成多个可以解决的小问题，在进行合并，每层递归的过程  分解-->解决-->合并。
     类似问题：二分搜索、大整数乘法、矩阵乘法、合并排序、快速排序等。
     https://leetcode.cn/problems/maximum-subarray/submissions/524100095/

10、四大算法之：回溯算法：
    主要是解决一些暴力枚举也解决不了的问题(组合、子集、分割、排列)，是一种基于深度优先的思想，通过减枝操作来减少搜索空间。
    从而找到问题的解。代码模板类似于递归算法
    例子：k个元素的组合，


11、四大算法之：动态规划算法：


12、BitMap的应用

13、A路寻星算法：A星寻路算法是一种高效、实用的路径搜索算法，
    它结合了广度优先搜索和最佳优先搜索的特点，通过启发式函数评估节点的重要性，从而快速找到最短路径


14、 二叉查找树可以提高节点查找的效率，并维持节点的有序性。
     b-树：多阶二叉树,便于查找元素，降低了树的高度，磁盘IO的次数更少，缺点是范围查找数据 不太适合
     和B+树：每个元素不保存数据，所有的原始都保存在叶子节点

15、 图：有向图：从a->b，但是从b不能到a点
        带权重的图：

        存储方式：1、 邻接矩阵(创建一个n*n的二位数组)，缺点：空间浪费大
                 2、邻接表法：创建一个一维数组+链表形式，表示当前节点能达到哪些节点（List<Integer[]>[] graph）
                 3、逆邻接表法：创建一个一维数组+链表形式，表示有哪些节点能达到当前节点
        遍历方式：深度遍历、广度遍历

        和二叉树的遍历很像，无非就是多了两个变量：
          visited[]：(节点已经被便利过，防止遍历时死循环)
          onpath[]：表示当前遍历时的路径，遍历后还需要撤销他的值，和回溯算法类似

        常见问题：
           遍历图
           检测图是否有环，以及返回环中的节点
           返回拓扑图(课程依赖问题之类的)：构造依赖有向图，在遍历节点，判断当前循环中是否有环，如果有环则不能完成拓扑，然后再节点的后续遍历中把
                    节点路径加入到list集合中，最后反序输出集合中的元素即可。为何反序？因为后续遍历【后】把前提元素(被依赖元素)加入到序列
           二分图：把图中的所有节点染成两种颜色中的一种，让任意一条边的两个节点的颜色都不相同，如果成立 则可以是二分图。(深度、广度都可以)
           并查集问题：就是动态联通问题，可以随时添加两个节点的联通，然后还有一个判断方法 判断两个节点是否联通。关键点就在于union和contion的效率
           如何提升？1、使用size[]数组 表示每个联通子图中节点的数量(联通时把小的挂在大的下面) 2、使用压缩算法(压缩到只有两层)
           最小生成树：数和图的最大区别就是：树不会形成环，但是图可能会形成环。最小生成树表示的是使用树中的某些节点把图中的所有节点都能串起来，同时
                      这些点的边的权重的和是最小的.
           kruskal:把权重的边进行排序，进行图的联通时，先选择权重小的边，如果一条边的两个点已经在连通图中了，则这条边不能被使用。
                  大白话就把边按权重排序，然后逐步加到联通图中，最后让联通图的分量变成1
           Prim   :算法也使用贪心思想来让生成树的权重尽可能小,其次，Prim 算法使用 BFS 算法思想 和visited布尔数组避免成环，来保证选出来的边最终形成的一定是一棵树。
                   他不需要先排序，而是使用优先级队列---动态排序
           Dijkstra:类似于二叉树的层序遍历(BFS),在distance数组中每次查找最短的距离，然后找到这个距离的顶点，再次计算从start到这个顶点的邻居节点M的距离是否
                    小于当前的距离，如果是小于，则更新到节点M的距离，再次循环。适用于【加权有向图，没有负权重边】
                    也支持只查询到指定节点的最短路径
           Bellman-Ford:

16、查找算法：
    有序数组的查找：二分查找法
    链表的查找：跳表
    字符串的匹配算法： BF暴力破解算法、 RK算法利用hash进行字符串匹配 、KMP算法
    KMP的关键: 其实就是在不匹配时，不是只向后移动一步，而是多次。
            KMP算法提高效率的关键，是对已匹配前缀的有效利用
         字符串的尾部有可能与自己的首部相匹配. 比如说字符串 abcab, 它的尾部有两个字符可以与自己的首部相匹配

17、BFS 算法 本质就是 从起点start找到终点target的最近距离
    双向BFS：传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。




经典算法问题总结：
1、名人问题：使用排除法，快速排除不是名人的候选人，最后再来一次遍历
2、岛屿问题：核心思想是使用DFS遍历，把岛屿变成海洋，然后统计岛屿的数量
3、LRU算法：使用Map+链表的方式，查询时能快速的把节点移动到头部
4、LFU算法，定义三个Map、两个变量(容量、最小频率），在插入、查询、删除时更新Map的值
5、trieMap:Trie 树中「树枝」存储字符串，「节点」存储字符串对应的值，主要操作：插入、删除、查找，最短前缀、最长前缀、按模式查找等
6、单调栈：下一个更大的元素，倒序遍历，然后和栈顶元素进行比较，直到栈顶为空或者栈顶元素大于他本身，则栈顶元素就是右侧最大的第一个元素
         环形数组，可以把数组扩展两倍计算
7、单调队列：在队尾添加元素，但是要把前面比新元素小的元素都删掉

8、链表相关题目：使用虚拟头尾节点，方便处理问题
  合并k个有序链表、
  翻转整个、翻转前k个链表、翻转m~n节点：递归写法和迭代写法，
  判断回文链表？1、从递归的后续位置和链表的头进行比较 2、找到链表的中点，在翻转后半段，然后在和前半段比较
  寻找链表的倒数第k个或者中间节点(快慢指针)
  是否有环，以及环的起点,【使用快慢指针】，起点：相交后，让任意一方从头开始走，他俩再次相遇，则是环的起点
  两个链表的相交节点：一个while循环，a链表循环结束则接上b链表，b结束则在接着a链表，如果他俩有相交，则最后的点是一个，因为(a+b)=(b+a) ,他俩长度相同
  链表中的快慢指针：遍历完成后：fast节点如果是空，则表示链表长度是偶数，否则是奇数

9、数组问题：
       1、原地修改数组，使用快慢指针
       2、滑动窗口问题，
       两数之和、三数之和、四数之和的通用写法，注意点：去除重复元素【跳过相邻相同元素】
9、判断回文字符串：
   寻找最长回文字符串：以i为中心向左右寻找，或者i,i+1为中心向左右两边查询
   寻找回文串是从中间向两端扩展，判断回文串是从两端向中间收缩。



动态数据结构：优先级队列、二叉平衡树

队列特点：队列位插入，队头出队，先进先出

双指针：链表一般使用快慢指针，数组一般使用双指针
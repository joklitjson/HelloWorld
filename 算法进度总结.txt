1、双指针法：就是在遍历数组或者链表中设置两个指针，根据指针运动方向的不同可以分为
    1.1 同向双指针(滑动窗口)
    1.2 对向（碰撞）双指针
    1.3 快慢指针：一般用于解决链表中的问题：
        比如：寻找链表的[中间点]寻找链表中倒数第K个元素、判断链表中是否存在环、排序链表（1、找中间点使用归并排序，2、插入排序 3、冒泡排序）
2、二分查找法：需要数组有序
3、栈：单调栈的特性，求解左侧或右侧最大值、最小，可以机选面积之类的
 比如：接雨水、k长度的最大元素 、最大面积

4、前后缀分解法：好下表的元素
https://zhuanlan.zhihu.com/p/671839485
前缀和:所谓前缀和，是指一个数组中的前i项的和。设有数组a[0...n]，那么s[i] = a[0] + ... + a[i]。
这样s数组就是a数组的前缀和数组。

https://zhuanlan.zhihu.com/p/637328901
5、滑动窗口:是双指针的一种特例算法，窗口大小固定，使用右指针向右移动。保持窗口期大小固定
    https://blog.csdn.net/qq_74534898/article/details/131563779

6、双指针算法：

8、四大算法之一---贪心算法：是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解
 比如：最短路径算法、找零钱、小孩分饼干，分发糖果
9、四大算法之：分治算法：分治算法是将一个规模为N的问题分解为K个规模较小的子问题;
     就是把一个的大规模的问题分解成多个可以解决的小问题，在进行合并，每层递归的过程  分解-->解决-->合并。
     类似问题：二分搜索、大整数乘法、矩阵乘法、合并排序、快速排序等。
     https://leetcode.cn/problems/maximum-subarray/submissions/524100095/

10、四大算法之：回溯算法：
    主要是解决一些暴力枚举也解决不了的问题(组合、子集、分割、排列)，是一种基于深度优先的思想，通过减枝操作来减少搜索空间。
    从而找到问题的解。代码模板类似于递归算法
    例子：k个元素的组合，


11、四大算法之：动态规划算法：


12、BitMap的应用

13、A路寻星算法：A星寻路算法是一种高效、实用的路径搜索算法，
    它结合了广度优先搜索和最佳优先搜索的特点，通过启发式函数评估节点的重要性，从而快速找到最短路径


14、 二叉查找树可以提高节点查找的效率，并维持节点的有序性。
     b-树：多阶二叉树,便于查找元素，降低了树的高度，磁盘IO的次数更少，缺点是范围查找数据 不太适合
     和B+树：每个元素不保存数据，所有的原始都保存在叶子节点

15、 图：有向图：从a->b，但是从b不能到a点
        带权重的图：

        存储方式：1、 邻接矩阵(创建一个n*n的二位数组)，缺点：空间浪费大
                 2、邻接表法：创建一个一维数组+链表形式，表示当前节点能达到哪些节点（List<Integer[]>[] graph）
                 3、逆邻接表法：创建一个一维数组+链表形式，表示有哪些节点能达到当前节点
        遍历方式：深度遍历、广度遍历

        和二叉树的遍历很像，无非就是多了两个变量：
          visited[]：(节点已经被便利过，防止遍历时死循环)
          onpath[]：表示当前遍历时的路径，遍历后还需要撤销他的值，和回溯算法类似

        常见问题：
           遍历图
           检测图是否有环，以及返回环中的节点
           返回拓扑图(课程依赖问题之类的)：构造依赖有向图，在遍历节点，判断当前循环中是否有环，如果有环则不能完成拓扑，然后再节点的后续遍历中把
                    节点路径加入到list集合中，最后反序输出集合中的元素即可。为何反序？因为后续遍历【后】把前提元素(被依赖元素)加入到序列
           二分图：把图中的所有节点染成两种颜色中的一种，让任意一条边的两个节点的颜色都不相同，如果成立 则可以是二分图。(深度、广度都可以)
           并查集问题：就是动态联通问题，可以随时添加两个节点的联通，然后还有一个判断方法 判断两个节点是否联通。关键点就在于union和contion的效率
           如何提升？1、使用size[]数组 表示每个联通子图中节点的数量(联通时把小的挂在大的下面) 2、使用压缩算法(压缩到只有两层)
           最小生成树：数和图的最大区别就是：树不会形成环，但是图可能会形成环。最小生成树表示的是使用树中的某些节点把图中的所有节点都能串起来，同时
                      这些点的边的权重的和是最小的.
           kruskal:把权重的边进行排序，进行图的联通时，先选择权重小的边，如果一条边的两个点已经在连通图中了，则这条边不能被使用。
                  大白话就把边按权重排序，然后逐步加到联通图中，最后让联通图的分量变成1
           Prim   :算法也使用贪心思想来让生成树的权重尽可能小,其次，Prim 算法使用 BFS 算法思想 和visited布尔数组避免成环，来保证选出来的边最终形成的一定是一棵树。
                   他不需要先排序，而是使用优先级队列---动态排序
           Dijkstra:类似于二叉树的层序遍历(BFS),在distance数组中每次查找最短的距离，然后找到这个距离的顶点，再次计算从start到这个顶点的邻居节点M的距离是否
                    小于当前的距离，如果是小于，则更新到节点M的距离，再次循环。适用于【加权有向图，没有负权重边】
                    也支持只查询到指定节点的最短路径
           Bellman-Ford:

16、查找算法：
    有序数组的查找：二分查找法
    链表的查找：跳表
    字符串的匹配算法： BF暴力破解算法、 RK算法利用hash进行字符串匹配 、KMP算法
    KMP的关键: 其实就是在不匹配时，不是只向后移动一步，而是多次。
            KMP算法提高效率的关键，是对已匹配前缀的有效利用
         字符串的尾部有可能与自己的首部相匹配. 比如说字符串 abcab, 它的尾部有两个字符可以与自己的首部相匹配

17、BFS 算法 本质就是 从起点start找到终点target的最近距离
    双向BFS：传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。




经典算法问题总结：
1、名人问题：使用排除法，快速排除不是名人的候选人，最后再来一次遍历
2、岛屿问题：核心思想是使用DFS遍历，把岛屿变成海洋，然后统计岛屿的数量
3、LRU算法：使用Map+链表的方式，查询时能快速的把节点移动到头部
4、LFU算法，定义三个Map、两个变量(容量、最小频率），在插入、查询、删除时更新Map的值